Eres un asistente técnico que toma el control de un repositorio de Python + Airflow/Kedro llamado ML_Analisis_Ecosistema_Dev.

Contexto breve (qué pasó):
- El repositorio fue ejecutado por un asistente previo que diagnosticó problemas de espacio y builds Docker muy pesadas (xgboost, scikit-learn, dvc...).
- Se preparó un SSD externo APFS montado en: /Volumes/HyperX y se creó la carpeta /Volumes/HyperX/ml_analisis_docker_data con permisos para el usuario.
- Se empezó a aplicar la estrategia: separar dependencias runtime vs dev y crear un overlay Compose para una imagen runtime ligera. Algunos archivos nuevos deben existir y/o verificarse.

Archivos clave que debes verificar ahora (y su ruta relativa al root del repo):
- docker/Dockerfile.runtime  (Dockerfile minimal para runtime)
- docker/docker-compose.runtime.yml  (overlay compose construido previamente)
- requirements-runtime.txt
- requirements-dev.txt
- scripts/setup-and-run.sh  (actualizado para preferir dev-reqs y usar overlay runtime)
- docs/RUNTIME_SETUP.md
- Dockerfile (raíz) — revisa que no haya cambios incompatibles

Objetivo inmediato (qué quieres lograr):
1) Confirmar que los archivos listados existen y contienen el contenido correcto (verifica que `Dockerfile.runtime` copia `requirements-runtime.txt` y que el overlay referencia ese Dockerfile).
2) Mover o usar el SSD externo para evitar problemas de espacio: el desarrollador está moviendo manualmente todo el repo al SSD y reiniciará el chat. Antes de que lo haga, prepara los pasos para cuando vuelva:
   - Hacer un rsync dry-run para estimar tamaño y luego rsync real hacia /Volumes/HyperX/ml_analisis_docker_data/ML_Analisis_Ecosistema_Dev
   - Crear backup de la carpeta original y un symlink desde la ruta original hacia la copia en el SSD
   - Ajustar permisos: chown -R $(id -u):$(id -g) y chmod 700 en la copia
3) Probar build del runtime: ejecutar
   docker compose -f docker-compose.yaml -f docker/docker-compose.runtime.yml build --pull --progress=plain
   y reportar errores/salida relevante.
4) Si el build pasa, arrancar en background y ejecutar smoke checks (verificar health endpoints, listar contenedores). Si falla, capturar logs y proponer mitigación.

Comandos útiles que debes ejecutar (en este orden cuando tengas el repo en el SSD):
- Verificar archivos:
  ls -la docker/Dockerfile.runtime requirements-runtime.txt docker/docker-compose.runtime.yml requirements-dev.txt
  sed -n '1,120p' docker/Dockerfile.runtime
  sed -n '1,60p' requirements-runtime.txt
- Dry-run rsync (para estimar):
  rsync -avh --progress --dry-run --exclude='.git' . /Volumes/HyperX/ml_analisis_docker_data/ML_Analisis_Ecosistema_Dev/
- Copiar realmente (cuando confirmes espacio):
  rsync -avh --progress --exclude='.git' . /Volumes/HyperX/ml_analisis_docker_data/ML_Analisis_Ecosistema_Dev/
- Hacer backup y symlink:
  mv /path/to/original /path/to/original.bak
  ln -s /Volumes/HyperX/ml_analisis_docker_data/ML_Analisis_Ecosistema_Dev /path/to/original
- Ajustar permisos:
  sudo chown -R "$(id -u):$(id -g)" /Volumes/HyperX/ml_analisis_docker_data/ML_Analisis_Ecosistema_Dev
  sudo chmod -R 700 /Volumes/HyperX/ml_analisis_docker_data/ML_Analisis_Ecosistema_Dev
- Build runtime image y ver logs:
  docker compose -f docker-compose.yaml -f docker/docker-compose.runtime.yml build --pull --progress=plain 2>&1 | tee /tmp/runtime_build.log
  docker compose -f docker-compose.yaml -f docker/docker-compose.runtime.yml up -d
  docker compose ps
  docker compose logs --tail=200

Criterios de éxito:
- `docker/Dockerfile.runtime` y `requirements-runtime.txt` están presentes y correctos.
- Build del runtime termina sin errores críticos y los servicios arrancan (al menos los containers alcanzan estado "healthy" o "Up").
- Si hay errores, devuelve los fragmentos de logs relevantes (/tmp/runtime_build.log y docker compose logs) y propon soluciones (por ejemplo, ajustar requirements, instalar libgomp, aumentar espacio, separar dev deps).

Si el desarrollador reinicia el chat y te da acceso a la carpeta en /Volumes/HyperX, repite este plan y ejecuta los comandos listados, capturando salidas y proponiendo correcciones.

Notas finales:
- Si detectas que las operaciones consumen demasiado espacio o tiempo, sugiere crear un workflow CI que compile y publique la imagen runtime en GHCR/DockerHub y que los devs la pullen en lugar de construir localmente.
- Mantén las respuestas cortas y técnicas: reporta comandos ejecutados, salida relevante y la siguiente acción recomendada.
